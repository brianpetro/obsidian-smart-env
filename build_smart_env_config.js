#!/usr/bin/env node
/**
 * build_smart_env_config.js
 *
 * Scans ./src for collections, items, components, and actions (supports sub-folders),
 * generates "./smart_env.config.js" with static import statements.
 *
 * Run: `node build_smart_env_config.js`
 */

import fs from 'fs';
import path from 'path';
import { to_pascal_case } from 'smart-utils/to_pascal_case.js';

const compare_strings = (a, b) => a.localeCompare(b);

export function build_smart_env_config(dist_dir, roots) {
  if (!fs.existsSync(dist_dir)) {
    fs.mkdirSync(dist_dir, { recursive: true });
  }

  const all_collections = {};
  const all_items = {};
  const all_modules = {};
  // Use a Map to ensure only the latest render import var is kept
  const all_components_flat_map = new Map();
  const all_components_nested = {};
  // actions
  const all_actions_flat_map = new Map();
  const all_actions_nested = {};

  for (const root of roots) {
    Object.assign(all_collections, scan_collections(root));
    Object.assign(all_items, scan_items(root));
    Object.assign(all_modules, scan_modules(root));
    const { flat, nested } = scan_components(root);
    // For each component, overwrite previous entry with same render import var
    flat.forEach(component_entry => {
      all_components_flat_map.set(component_entry.render_import_var, component_entry);
    });
    deep_merge(all_components_nested, nested);

    // actions
    const { entries: action_entries, nested: a_nested } = scan_actions(root);
    action_entries.forEach(entry => {
      all_actions_flat_map.set(entry.action_import_var, entry);
    });
    deep_merge(all_actions_nested, a_nested);
  }

  const all_components_flat = Array.from(all_components_flat_map.values())
    .sort((a, b) => compare_strings(a.render_import_var, b.render_import_var));
  const all_actions_flat = Array.from(all_actions_flat_map.values())
    .sort((a, b) => compare_strings(a.action_import_var, b.action_import_var));

  /* ----------  IMPORT STRINGS ---------- */
  const collection_imports = Object.entries(all_collections)
    .sort(([a], [b]) => compare_strings(a, b))
    .map(([name, p]) => `import ${name} from '${p}';`)
    .join('\n');

  const sorted_items = Object.entries(all_items).sort(([a], [b]) => compare_strings(a, b));

  const item_imports = sorted_items
    .map(([, { import_var, import_path }]) => `import { ${import_var} } from '${import_path}';`)
    .join('\n');

  const module_imports = Object.entries(all_modules)
    .sort(([a], [b]) => compare_strings(a, b))
    .map(([name, p]) => `import ${name} from '${p}';`)
    .join('\n');

  const component_imports = all_components_flat
    .map(({ render_import_var, settings_import_var, import_path }) => {
      const specs = [`render as ${render_import_var}`];
      if (settings_import_var) {
        specs.push(`settings_config as ${settings_import_var}`);
      }
      return `import { ${specs.join(', ')} } from '${import_path}';`;
    })
    .join('\n');

  // actions
  const action_imports = all_actions_flat
    .map(({
      action_export_name,
      action_import_var,
      settings_export_name,
      settings_import_var,
      display_name_export_name,
      display_name_import_var,
      display_description_export_name,
      display_description_import_var,
      pre_process_export_name,
      pre_process_import_var,
      import_path
    }) => {
      const specs = [`${action_export_name} as ${action_import_var}`];
      if (display_name_export_name) {
        specs.push(`${display_name_export_name} as ${display_name_import_var}`);
      }
      if (display_description_export_name) {
        specs.push(`${display_description_export_name} as ${display_description_import_var}`);
      }
      if (settings_export_name) {
        specs.push(`${settings_export_name} as ${settings_import_var}`);
      }
      if (pre_process_export_name) {
        specs.push(`${pre_process_export_name} as ${pre_process_import_var}`);
      }
      return `import { ${specs.join(', ')} } from '${import_path}';`;
    })
    .join('\n');

  /* ----------  CONFIG OBJECT STRINGS ---------- */
  const collections_config = obj_keys_to_lines(all_collections, 4).join(',\n');

  const item_types_config = sorted_items
    .map(([, { import_var }]) => `    ${import_var}`)
    .join(',\n');

  const items_config = sorted_items
    .map(([key, { import_var }]) => `    ${key}: { class: ${import_var} }`)
    .join(',\n');

  const modules_config = obj_keys_to_lines(all_modules, 4).join(',\n');
  const components_config = components_to_string(all_components_nested, 4);
  // actions
  const actions_config = actions_to_string(all_actions_nested, 4);

  const final_code = [
    '// AUTO-GENERATED by build_smart_env_config.js. DO NOT EDIT.',
    collection_imports,
    item_imports,
    module_imports,
    component_imports,
    action_imports,
    `
export const smart_env_config = {
  collections: {
${collections_config}
  },
  item_types: {
${item_types_config}
  },
  items: {
${items_config}
  },
  modules: {
${modules_config}
  },
  components: {
${components_config}
  },
  actions: {
${actions_config}
  }
};
`
  ].join('\n');

  const out_file = path.join(dist_dir, 'smart_env.config.js');
  fs.writeFileSync(out_file, final_code, 'utf-8');
  console.log(`Wrote ${out_file}`);

  /* ----------  HELPERS ---------- */
  function normalize_relative_path(abs_path) {
    let rel = path.relative(dist_dir, abs_path).replace(/\\/g, '/');
    if (!rel.startsWith('.')) rel = './' + rel;
    return rel;
  }

  function read_dir_sorted(dir_path) {
    return fs.readdirSync(dir_path).sort(compare_strings);
  }

  function scan_collections(base_dir) {
    const dir = path.join(base_dir, 'collections');
    if (!fs.existsSync(dir)) return {};
    return Object.fromEntries(
      read_dir_sorted(dir)
        .filter(f => validate_file_type(f))
        .map(f => [to_snake_case(f.replace('.js', '')), normalize_relative_path(path.join(dir, f))])
    );
  }

  function scan_items(base_dir) {
    const dir = path.join(base_dir, 'items');
    if (!fs.existsSync(dir)) return {};
    const items = {};
    read_dir_sorted(dir)
      .filter(f => validate_file_type(f))
      .forEach(f => {
        const key = to_snake_case(f.replace('.js', ''));
        const import_var = to_pascal_case(key);
        items[key] = { import_var, import_path: normalize_relative_path(path.join(dir, f)) };
      });
    return items;
  }

  function scan_modules(base_dir) {
    const dir = path.join(base_dir, 'modules');
    if (!fs.existsSync(dir)) return {};
    return Object.fromEntries(
      read_dir_sorted(dir)
        .filter(f => validate_file_type(f))
        .map(f => [to_snake_case(f.replace('.js', '')), normalize_relative_path(path.join(dir, f))])
    );
  }

  /**
   * Recursively walks components and builds:
   *   - flat array of {render_import_var, settings_import_var, import_path} (for imports)
   *   - nested object describing final config tree
   */
  function scan_components(base_dir) {
    const dir = path.join(base_dir, 'components');
    if (!fs.existsSync(dir)) return { flat: [], nested: {} };

    const flat = [];
    const nested = {};

    walk(dir, []);

    return { flat, nested };

    /* ----- local ----- */
    function walk(curr_dir, rel_parts) {
      read_dir_sorted(curr_dir)
        .forEach(entry => {
          const abs = path.join(curr_dir, entry);
          const is_dir = fs.statSync(abs).isDirectory();
          if (is_dir) {
            walk(abs, [...rel_parts, entry]);
            return;
          }
          if (!validate_file_type(entry)) return;

          // skip if no named render export
          const content = fs.readFileSync(abs, 'utf-8');
          if (!has_named_export(content, 'render')) return;
          const has_settings_config = has_named_export(content, 'settings_config');

          const comp_name = entry.replace('.js', '');
          const comp_key = to_snake_case(comp_name);
          const folder_snake = rel_parts.map(to_snake_case);
          const render_import_var = [...folder_snake, comp_key, 'component'].join('_');
          const settings_import_var = has_settings_config ? `${render_import_var}_settings_config` : null;
          const import_path = normalize_relative_path(abs);

          // Remove previous entry with same render import var (keep newer)
          const prevIdx = flat.findIndex(e => e.render_import_var === render_import_var);
          if (prevIdx !== -1) flat.splice(prevIdx, 1);

          /* flat list */
          flat.push({ render_import_var, settings_import_var, import_path });

          /* nested object */
          let node = nested;
          for (const part of folder_snake) {
            if (!node[part]) node[part] = {};
            node = node[part];
          }
          node[comp_key] = { render_import_var };
          if (settings_import_var) {
            node[comp_key].settings_import_var = settings_import_var;
          }
        });
      ;
    }
  }

  /**
   * Recursively walks actions and builds:
   *   - entries describing import needs
   *   - nested object describing final config tree
   *
   * Rules:
   *  - expected export is the same name as the file (without .js)
   *  - actions object uses the same name as the file as the property key
   */
  function scan_actions(base_dir) {
    const dir = path.join(base_dir, 'actions');
    if (!fs.existsSync(dir)) return { entries: [], nested: {} };

    const entries = [];
    const nested = {};

    walk(dir, []);

    return { entries, nested };

    function walk(curr_dir, rel_parts) {
      read_dir_sorted(curr_dir).forEach(entry => {
        const abs = path.join(curr_dir, entry);
        const is_dir = fs.statSync(abs).isDirectory();
        if (is_dir) {
          walk(abs, [...rel_parts, entry]);
          return;
        }
        if (!validate_file_type(entry)) return;

        const action_name = entry.replace('.js', '');
        const action_key = to_snake_case(action_name);
        const content = fs.readFileSync(abs, 'utf-8');

        // Require a named export matching the file name
        const has_action_export = has_named_export(content, action_name);

        if (!has_action_export) return;

        const has_settings_config = has_named_export(content, 'settings_config');
        const has_display_name = has_named_export(content, 'display_name');
        const has_display_description = has_named_export(content, 'display_description');
        const has_pre_process = has_named_export(content, 'pre_process');

        const folder_snake = rel_parts.map(to_snake_case);
        const import_var = [...folder_snake, action_key, 'action'].join('_');
        const import_path = normalize_relative_path(abs);
        const export_name = action_name;
        const settings_import_var = has_settings_config ? `${import_var}_settings_config` : null;
        const display_name_import_var = has_display_name ? `${import_var}_display_name` : null;
        const display_description_import_var = has_display_description ? `${import_var}_display_description` : null;
        const pre_process_import_var = has_pre_process ? `${import_var}_pre_process` : null;
        // Remove previous entry with same import_var (keep newer)
        const prevIdx = entries.findIndex(e => e.action_import_var === import_var);
        if (prevIdx !== -1) entries.splice(prevIdx, 1);

        // flat list
        entries.push({
          action_export_name: export_name,
          action_import_var: import_var,
          settings_export_name: has_settings_config ? 'settings_config' : null,
          settings_import_var,
          display_name_export_name: has_display_name ? 'display_name' : null,
          display_name_import_var,
          display_description_export_name: has_display_description ? 'display_description' : null,
          display_description_import_var,
          pre_process_export_name: has_pre_process ? 'pre_process' : null,
          pre_process_import_var,
          import_path
        });

        // nested object (keys use the same name as the file)
        let node = nested;
        for (const part of folder_snake) {
          if (!node[part]) node[part] = {};
          node = node[part];
        }
        node[action_key] = { action_import_var: import_var };
        if (has_settings_config) {
          node[action_key].settings_import_var = settings_import_var;
        }
        if (has_display_name) {
          node[action_key].display_name_import_var = display_name_import_var;
        }
        if (has_display_description) {
          node[action_key].display_description_import_var = display_description_import_var;
        }
        if (has_pre_process) {
          node[action_key].pre_process_import_var = pre_process_import_var;
        }
      });
    }
  }

  /* ----- util helpers ----- */
  function to_snake_case(s) {
    return s
      .replace(/[-\s]+/g, '_')
      .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
      .toLowerCase();
  }
  function obj_keys_to_lines(obj, indent = 2) {
    const spacer = ' '.repeat(indent);
    return Object.keys(obj)
      .sort(compare_strings)
      .map(k => `${spacer}${k}`);
  }
  function deep_merge(target, src) {
    Object.entries(src).forEach(([k, v]) => {
      if (typeof v === 'object' && !Array.isArray(v)) {
        if (!target[k]) target[k] = {};
        deep_merge(target[k], v);
      } else {
        target[k] = v;
      }
    });
  }
  function components_to_string(node, indent = 2) {
    const spacer = ' '.repeat(indent);
    const parts = [];
    Object.entries(node)
      .sort(([a], [b]) => compare_strings(a, b))
      .forEach(([k, v]) => {
        if (v.render_import_var) {
          const inner = [`render: ${v.render_import_var}`];
          if (v.settings_import_var) inner.push(`settings_config: ${v.settings_import_var}`);
          parts.push(`${spacer}${k}: { ${inner.join(', ')} }`);
        } else {
          const inner = components_to_string(v, indent + 2);
          parts.push(`${spacer}${k}: {\n${inner}\n${spacer}}`);
        }
      });
    return parts.join(',\n');
  }
  function actions_to_string(node, indent = 2) {
    const spacer = ' '.repeat(indent);
    const parts = [];
    Object.entries(node)
      .sort(([a], [b]) => compare_strings(a, b))
      .forEach(([k, v]) => {
        if (v.action_import_var) {
          const inner = [`action: ${v.action_import_var}`];
          if (v.display_name_import_var) inner.push(`display_name: ${v.display_name_import_var}`);
          if (v.display_description_import_var) inner.push(`display_description: ${v.display_description_import_var}`);
          if (v.settings_import_var) inner.push(`settings_config: ${v.settings_import_var}`);
          if (v.pre_process_import_var) inner.push(`pre_process: ${v.pre_process_import_var}`);
          parts.push(`${spacer}${k}: { ${inner.join(', ')} }`);
        } else {
          const inner = actions_to_string(v, indent + 2);
          parts.push(`${spacer}${k}: {\n${inner}\n${spacer}}`);
        }
      });
    return parts.join(',\n');
  }
}
function validate_file_type(f) {
  if(f.endsWith('.test.js')) return false;
  if(f.endsWith('.spec.js')) return false;
  return f.endsWith('.js');
}

function has_named_export(content, name) {
  if (content.includes(`export function ${name}`)) return true;
  if (content.includes(`export async function ${name}`)) return true;
  if (content.includes(`export const ${name}`)) return true;
  if (content.includes(`export let ${name}`)) return true;
  if (content.includes(`export var ${name}`)) return true;
  return new RegExp(`export\\s*\\{[^}]*\\b${name}\\b[^}]*\\}`).test(content);
}
