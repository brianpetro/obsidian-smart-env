/* eslint-env node */
/* global __dirname */

import fs from 'fs';
import os from 'os';
import path from 'path';
import { pathToFileURL } from 'url';
import test from 'ava';
import { build_smart_env_config } from './build_smart_env_config.js';

/** -------------------------------------------------------------------
 * helpers – snake_case, two-space indent, no extra deps
 * ------------------------------------------------------------------*/
const tmp_root = fs.mkdtempSync(path.join(os.tmpdir(), 'smart-env-test-'));

function write_file(rel, contents = '') {
  const abs = path.join(tmp_root, rel);
  fs.mkdirSync(path.dirname(abs), { recursive: true });
  fs.writeFileSync(abs, contents);
}

function read_generated_config() {
  const p = path.join(tmp_root, 'smart_env.config.js');
  return fs.readFileSync(p, 'utf-8');
}

/** -------------------------------------------------------------------
 * Setup fixture project
 * ------------------------------------------------------------------*/
test.before(() => {
  /* collections */
  write_file('src/collections/notes.js', 'export default class Notes {}');
  write_file('src/collections/alpha.js', 'export default class Alpha {}');
  write_file('src/collections/ZetaConnections.js', 'export default class ZetaConnections {}');

  /* items */
  write_file('src/items/awesome_block.js', 'export function AwesomeBlock(){}');
  write_file('src/items/awesome_block.test.js', 'export function AwesomeBlock(){}');
  write_file('src/items/betaBlock.js', 'export function BetaBlock(){}');

  /* components – root level */
  write_file(
    'src/components/env_settings.js',
    `export function render(){}
export const settings_config = { theme: 'dark' };`
  );

  /* components – one level */
  write_file('src/components/smart-sources/settings.js', 'export function render(){}');
  write_file(
    'src/components/ConnectionsListItem/V2Settings.js',
    'export function render(){}'
  );
  write_file(
    'src/components/connections-list-item/v3.js',
    'export function render(){}'
  );

  /* actions */
  write_file('src/actions/publish.js', `export function publish(){ return 'action'; }
export const display_name = 'Publish Action';
export const display_description = 'Send a note to publish';
export const settings_config = { foo: 'bar' };
`);
  write_file('src/actions/log.js', 'export function log(){}');
  write_file('src/actions/smart-sources/sync.js', 'export function sync(){}');
  write_file('src/actions/RankConnections.js', 'export function RankConnections(){}');
  write_file(
    'src/actions/connections-list/PreProcess.js',
    `export function PreProcess(){}
export const pre_process = () => 'prep';`
  );

  /* modules */
  write_file(
    'src/modules/activity_feed.js',
    `export default {
  key: 'activity_feed',
  init(){ return 'activity'; }
};`
  );
  write_file(
    'src/modules/ConfigGuide.js',
    `export default {
  key: 'config_guide',
  bootstrap(){ return 'config'; }
};`
  );
  write_file(
    'src/modules/zeta-monitor.js',
    `export default {
  key: 'zeta_monitor',
  init(){ return 'monitor'; }
};`
  );

});

/** -------------------------------------------------------------------
 * build config once for all tests
 * ------------------------------------------------------------------*/
test.before(async () => {
  build_smart_env_config(tmp_root, [path.join(tmp_root, 'src')]);
});

/** -------------------------------------------------------------------
 * Tests
 * ------------------------------------------------------------------*/
test('banner comment exists', t => {
  const file = read_generated_config();
  t.true(file.startsWith('// AUTO-GENERATED by build_smart_env_config.js'));
});

test('collections are gathered', t => {
  const file = read_generated_config();
  t.regex(file, /collections:[\s\S]*notes/);
});

test('items are imported with PascalCase vars', t => {
  const file = read_generated_config();
  t.regex(file, /import { AwesomeBlock } from/);
  t.regex(file, /item_types:[\s\S]*AwesomeBlock/);
});
test('should skip .test.js files', t => {
  const file = read_generated_config();
  t.false(file.includes('AwesomeBlock.test.js'));
});

test('root-level component appears in config', t => {
  const file = read_generated_config();
  t.regex(file, /components:[\s\S]*env_settings:/);
});

test('nested component folder is snake_cased', t => {
  const file = read_generated_config();
  // smart-sources -> smart_sources
  t.regex(file, /smart_sources:[\s\S]*settings:/);
});

test('component file names are converted to snake_case keys', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { components } = cfg.smart_env_config;
  t.truthy(components.connections_list_item.v2_settings);
  t.truthy(components.connections_list_item.v3);
});

test('generated module is importable', async t => {
  /* The dynamic import will execute the generated import stmts.
     Because fixture component/item files exist, it should resolve. */
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  t.truthy(cfg.smart_env_config);
  t.truthy(cfg.smart_env_config.components.env_settings);
  t.truthy(cfg.smart_env_config.items.awesome_block);
});

test('components config exposes render function on render property', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { components } = cfg.smart_env_config;
  t.is(typeof components.env_settings.render, 'function');
  t.is(typeof components.smart_sources.settings.render, 'function');
});

test('components config includes settings_config when exported', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { components } = cfg.smart_env_config;
  t.deepEqual(components.env_settings.settings_config, { theme: 'dark' });
  t.false(
    Object.prototype.hasOwnProperty.call(
      components.smart_sources.settings,
      'settings_config'
    )
  );
});

test('actions config stores action export on action property', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { actions } = cfg.smart_env_config;
  t.is(typeof actions.publish.action, 'function');
  t.is(typeof actions.log.action, 'function');
});

test('actions config includes settings_config when exported', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { publish } = cfg.smart_env_config.actions;
  t.deepEqual(publish.settings_config, { foo: 'bar' });
});

test('actions config includes display metadata when exported', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { publish, log } = cfg.smart_env_config.actions;
  t.is(publish.display_name, 'Publish Action');
  t.is(publish.display_description, 'Send a note to publish');
  t.false(Object.prototype.hasOwnProperty.call(log, 'display_name'));
  t.false(Object.prototype.hasOwnProperty.call(log, 'display_description'));
});

test('actions nested folders are snake_cased in config', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { actions } = cfg.smart_env_config;
  t.is(typeof actions.smart_sources.sync.action, 'function');
});

test('action filenames are sanitized to snake_case keys', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { actions } = cfg.smart_env_config;
  t.is(typeof actions.rank_connections.action, 'function');
  t.is(typeof actions.connections_list.pre_process.action, 'function');
});

test('modules are collected and exposed on config', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { modules } = cfg.smart_env_config;
  t.truthy(modules.activity_feed);
  t.is(modules.activity_feed.key, 'activity_feed');
  t.is(typeof modules.activity_feed.init, 'function');
  t.truthy(modules.config_guide);
  t.is(modules.config_guide.key, 'config_guide');
  t.is(typeof modules.config_guide.bootstrap, 'function');
  t.truthy(modules.zeta_monitor);
  t.is(typeof modules.zeta_monitor.init, 'function');
});

test('collections keys are sorted lexicographically', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const keys = Object.keys(cfg.smart_env_config.collections);
  t.deepEqual(keys, [...keys].sort());
});

test('items config keys are sorted lexicographically', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const keys = Object.keys(cfg.smart_env_config.items);
  t.deepEqual(keys, [...keys].sort());
});

test('modules config keys are sorted lexicographically', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const keys = Object.keys(cfg.smart_env_config.modules);
  t.deepEqual(keys, [...keys].sort());
});

test('components keys are sorted lexicographically', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const keys = Object.keys(cfg.smart_env_config.components);
  t.deepEqual(keys, [...keys].sort());
});

test('actions config keys are sorted lexicographically', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const keys = Object.keys(cfg.smart_env_config.actions);
  t.deepEqual(keys, [...keys].sort());
});

test('nested action keys are sorted lexicographically', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const nested_keys = Object.keys(cfg.smart_env_config.actions.connections_list);
  t.deepEqual(nested_keys, [...nested_keys].sort());
});

test('actions include pre_process export when provided', async t => {
  const mod_path = path.join(tmp_root, 'smart_env.config.js');
  const cfg = await import(pathToFileURL(mod_path).href);
  const { pre_process } = cfg.smart_env_config.actions.connections_list.pre_process;
  t.is(typeof pre_process, 'function');
  t.is(pre_process(), 'prep');
});


test.after.always(() => {
  fs.rmSync(tmp_root, { recursive: true, force: true });
});
